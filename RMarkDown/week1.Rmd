---
title: "week1"
author: "Rajesh Kalakoti"
date: "2023-08-03"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## R Markdown

This is an R Markdown document. Markdown is a simple formatting syntax for authoring HTML, PDF, and MS Word documents. For more details on using R Markdown see <http://rmarkdown.rstudio.com>.

When you click the **Knit** button a document will be generated that includes both content as well as the output of any embedded R code chunks within the document. You can embed an R code chunk like this:

```{r cars}
# Load required libraries
# Load required libraries
library(plotly)

# Function to calculate different distances
calculate_distance <- function(x1, y1, x2, y2, distance_type) {
  if (distance_type == "euclidean") {
    return(sqrt((x2 - x1)^2 + (y2 - y1)^2))
  } else if (distance_type == "manhattan") {
    return(abs(x2 - x1) + abs(y2 - y1))
  } else if (distance_type == "minkowsky1") {
    return((abs(x2 - x1)^1 + abs(y2 - y1)^1)^(1/1))
  } else if (distance_type == "minkowsky2") {
    return((abs(x2 - x1)^2 + abs(y2 - y1)^2)^(1/2))
  } else if (distance_type == "chebyshev") {
    return(max(abs(x2 - x1), abs(y2 - y1)))
  } else {
    stop("Invalid distance type")
  }
}

# Generate random points for the first and second dimensions
set.seed(123)  # Set seed for reproducibility
n_points <- 30
dimension1 <- runif(n_points, -5, 5)
dimension2 <- runif(n_points, -5, 5)

# Generate grid points for creating surface plots
resolution <- 1000
x_grid <- seq(-5, 5, length.out = resolution)
y_grid <- seq(-5, 5, length.out = resolution)

# Calculate distance surfaces for different distance metrics
distance_types <- c("euclidean", "manhattan", "minkowsky1", "minkowsky2", "chebyshev")

# Create an empty list to store the surface plots
distance_plots <- list()

# Custom color scales for each distance type
color_scales <- c("RdYlBu", "Greens", "Reds", "Blues", "Oranges")

for (i in seq_along(distance_types)) {
  z_grid <- matrix(0, nrow = resolution, ncol = resolution)  # Adjust z_grid here
  
  for (j in seq_along(x_grid)) {
    for (k in seq_along(y_grid)) {
      z_grid[j, k] <- calculate_distance(x_grid[j], y_grid[k], dimension1, dimension2, distance_types[i])[1]
    }
  }
  
  # Create the 3D surface plot and add to the list
  distance_plots[[i]] <- plot_ly(x = x_grid, y = y_grid, z = z_grid, type = "surface", colorscale = color_scales[i],
                                 name = distance_types[i], opacity = 0.8)
}

# Combine all the distance plots into one visualization
combined_plot <- subplot(distance_plots, nrows = 1, titleX = FALSE, titleY = FALSE)
combined_plot <- layout(combined_plot, title = "3D Surface Plot of Impact Distances",
                        scene = list(xaxis = list(title = "Dimension 1"),
                                     yaxis = list(title = "Dimension 2"),
                                     zaxis = list(title = "Distance")))

# Show the combined plot
print(combined_plot)



```

## Including Plots

You can also embed plots, for example:

```{r pressure, echo=FALSE}
# Load required libraries
library(plotly)

# Function to calculate different distances
calculate_distance <- function(x1, y1, x2, y2, distance_type) {
  if (distance_type == "euclidean") {
    return(sqrt((x2 - x1)^2 + (y2 - y1)^2))
  } else if (distance_type == "manhattan") {
    return(abs(x2 - x1) + abs(y2 - y1))
  } else if (distance_type == "minkowsky1") {
    return((abs(x2 - x1)^1 + abs(y2 - y1)^1)^(1/1))
  } else if (distance_type == "minkowsky2") {
    return((abs(x2 - x1)^2 + abs(y2 - y1)^2)^(1/2))
  } else if (distance_type == "chebyshev") {
    return(max(abs(x2 - x1), abs(y2 - y1)))
  } else {
    stop("Invalid distance type")
  }
}

# Generate random points for the first and second dimensions
set.seed(123)  # Set seed for reproducibility
n_points <- 30
dimension1 <- runif(n_points, -5, 5)
dimension2 <- runif(n_points, -5, 5)

# Generate grid points for creating surface plots
resolution <- 50
x_grid <- seq(-5, 5, length.out = resolution)
y_grid <- seq(-5, 5, length.out = resolution)

# Calculate distance surfaces for different distance metrics
distance_types <- c("euclidean", "manhattan", "minkowsky1", "minkowsky2", "chebyshev")

# Create an empty list to store the surface plots and cones
distance_plots <- list()
cone_plots <- list()

# Custom color scales for each distance type
color_scales <- c("RdYlBu", "Greens", "Reds", "Blues", "Oranges")

for (i in seq_along(distance_types)) {
  z_grid <- matrix(0, nrow = resolution, ncol = resolution)  # Adjust z_grid here
  
  for (j in seq_along(x_grid)) {
    for (k in seq_along(y_grid)) {
      z_grid[j, k] <- calculate_distance(x_grid[j], y_grid[k], dimension1, dimension2, distance_types[i])[1]
    }
  }
  
  # Create the 3D surface plot and add to the list
  distance_plots[[i]] <- plot_ly(x = x_grid, y = y_grid, z = z_grid, type = "surface", colorscale = color_scales[i],
                                 name = distance_types[i], opacity = 0.8)
  
  # Add cones to the plot
  cone_plots[[i]] <- add_cones(distance_plots[[i]], x = dimension1, y = dimension2, z = z_grid,
                               sizemode = "absolute", sizeref = 0.3, anchor = "tip",
                               showscale = FALSE, opacity = 0.5)
}

# Combine all the distance plots and cones into one visualization
combined_plot <- subplot(distance_plots, nrows = 1, titleX = FALSE, titleY = FALSE)
for (i in seq_along(cone_plots)) {
  combined_plot <- subplot(combined_plot, cone_plots[[i]])
}

combined_plot <- layout(combined_plot, title = "3D Surface Plot of Impact Distances with Cones",
                        scene = list(xaxis = list(title = "Dimension 1"),
                                     yaxis = list(title = "Dimension 2"),
                                     zaxis = list(title = "Distance")))

# Show the combined plot
print(combined_plot)

```

Note that the `echo = FALSE` parameter was added to the code chunk to prevent printing of the R code that generated the plot.
